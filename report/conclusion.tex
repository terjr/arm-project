\section{Conclusion}
The ultimate goal of an experiment 


This is where we will put the conclusion

Observations (regarding this architecture):
Status flag update instructions are cheaper than their non-updating counterpart.
Energy consumption is generally dominated by instruction cycle count.
The results are stable (when doing multiple runs, each runs compare well with
        previous ones)

Our measures of the multiply and other serializing instructions should probably
be checked more into, as the performance counters in \autoref{tab:perf_mul} and
\autoref{tab:perf_nonmul} shows different degree of idleness over the different
instructions, even though we have tried to avoid this.  This is probably a
matter of rewriting the kernel modules used for instruction testing, and we
simply had no more time investigating this matter.

Our final conclusion would be that the ARM Cortex-A9 is a processor core that
seems to be well balanced in terms of energy consumption over each instruction,
and there are no enormeous peaks or spikes in our measurements. It seems to be
serialization due to the conditional execution paradigm and delayed result
writing in multiplication that cause most problems. These instructions serialize
this out-of-order core in such a way that a lot of stalls occur, and the
processor wastes energy while idling.



\subsection{Further Work}

Our work relies completely on synthetic benchmarks, and we do not know how this
would differ from real world workloads. The synthetic tests fill the pipeline
with equal instructions, while common workloads would at least contain a few
different instructions simultaneously.

\todo{fix} Go deeper into the meaning of perf.counters and how they affect serialization, and
how much power is really wasted on idle cycles.

Also, we have not yet dived into how instruction operands affects the energy usage on
modern processors. We believe that instruction patterns that causes a high
degree of bit toggling would yield higher energy usage, due to the amount of
energy used to charge and release the transistors. A problem rising is the fact
that we do not know how the processor schedules or distributes the different
instructions, thus one has to be very careful when writing the benchmarks.

When selecting instructions for our benchmarks, we have omitted the set of
floating-point instructions. This is because in the ARM Cortex-A9, the floating
point unit (NEON) is considered a co-processor\cite{armtech}, and thus out of
our scope. Investigating the energy efficiency of co-processors versus
processors that embed such functionality would add value to our results.

There are also room for improvement regarding the experimental setup. Ultimately,
one would like to be able to measure each instruction individualy, but according
to the Nyquist-Shannon theorem\cite{shannon1949communication}, this would
require a sampling rate of at least 3.4 GHz. We could not simply go slower on
the clock, as a clock frequency reduction will affect the energy
efficiency, possibly in the negative direction\cite{burd1995energy}.
