\section{Conclusion}
The ultimate goal of an experiment 


This is where we will put the conclusion

Observations (regarding this architecture):
Status flag update instructions are cheaper than their non-updating counterpart.
Energy consumption is generally dominated by instruction cycle count.
The results are stable (when doing multiple runs, each runs compare well with
        previous ones)




\subsection{Further Work}

Our work relies completely on synthetic benchmarks, and we do not know how this
would differ from real world workloads. The synthetic tests fill the pipeline
with equal instructions, while common workloads would at least contain a few
different instructions simultaneously. 

Also, we have not yet dived into how instruction operands affects the energy usage on
modern processors. We believe that instruction patterns that causes a high
degree of bit toggling would yield higher energy usage, due to the amount of
energy used to charge and release the transistors. A problem rising is the fact
that we do not know how the processor schedules or distributes the different
instructions, thus one has to be very careful when writing the benchmarks.

When selecting instructions for our benchmarks, we have omitted the set of
floating-point instructions. This is because in the ARM Cortex-A9, the floating
point unit (NEON) is considered a co-processor\cite{armtech}, and thus out of
our scope. Investigating the energy efficiency of co-processors versus
processors that embed such functionality would add value to our results.

There are also room for improvement regarding the experimental setup. Ultimately,
one would like to be able to measure each instruction individualy, but according
to the Nyquist-Shannon theorem\cite{shannon1949communication}, this would
require a sampling rate of at least 3.4 GHz. We could not simply go slower on
the clock, as a clock frequency reduction will affect the energy
efficiency, possibly in the negative direction\cite{burd1995energy}.
