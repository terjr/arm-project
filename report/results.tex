\section{Results}

%\begin{figure*}
%    \centering
%    \includegraphics[width=1.1\textwidth]{figures/graph_0123_base_lowpower_mul-0c6}
%    \label{fig:allmul}
%\end{figure*}
%
%\begin{figure*}
%    \centering
%    \includegraphics[width=0.7\textwidth]{figures/graph_0123_base_mul-0c7}
%    \label{fig:allmul}
%\end{figure*}
%
%
%
%\begin{figure*}
%    \centering
%    \subfloat[][Multiply]
%    {
%        \includegraphics[width=0.49\textwidth]{figures/graph_123_base_mul-0c5}
%        \label{fig:somemul}
%    }
%    \subfloat[][Single Cycle]
%    {
%        \includegraphics[width=0.49\textwidth]{figures/graph_1_base_arith_data_logic-0c5}
%        \label{fig:singlecycle}
%    }
%    \caption{test}
%\end{figure*}

\begin{figure*}[ht]
    \centering
    \includegraphics[width=\textwidth]{figures/graph_01_base_arith_saturate_data_pack_logic-0c6}
    \caption{Energy profile of single-cycle instructions, excluding multiply.}
    \label{fig:singlecycle}
\end{figure*}


\subsection{Introduction}
In this section we present data gathered from our experiments on the ARM
Cortex-A9. A brief description of each instruction can be found in the "ARM and
Thumb-2 Instruction Set Quick Reference Card"\cite{armasmref}.

We distinguish between single-cycle instructions and multi-cycle instructions
because they behave differently in and around the execution pipeline.
Instructions consuming only one cycle are fairly easy to reason about as there
is no need to normalize energy consumption with respect to the cycle count (i.e.
time). However, it is important to also recognize CPU capabilities such as dual
issuing that we have on our processor: All single-cycle ALU instructions execute
pairwise in parallel (one in each ALU), giving a peak performance of two
instructions per CPU cycle. On the other hand, multi-cycle instructions needs to
be carefully considered. Typically, multi-cycle instructions divide work which
can be done only in a subset of the available CPUs (e.g. one) over several
cycles, lowering the average current draw. They consume less energy per time
step, but also do less useful work. For all these reasons, we partition the
measured data in two data sets; one for single-cycle instructions and one for
multi-cycle instructions.

Observational errors are accounted for by running the power measurement loop
many times for each instruction. We also sleep 30 seconds in between
instructions to diminish the effect of temperature variations. Running over all
tested instructions typically takes 3 hours and we average the medians for each
instruction run to get a single value.

In the graphs, all bars colored green means that the tested instruction is a
single-cycle instruction, the light blue is two-cycles, and dark blue is
three-cycle instructions. The red bar is the baseline for power measurement.
This baseline is an alias for the least power-consuming instruction we could
find, which is the {\ttfamily setend}-instruction. This instruction sets the
endianness regarding memory operations to eiter big or little
endian \cite{armcompilerref} and setting it to the same endian repeatedly would
resemble constant halting on our processor.

The results presented in the graphs are enumerated as Ampere
$\cdot$ cycles, which means that instructions using more time is normalized by
adding up their power drain with the time used in the pipeline. The results are
not converted into watts, joule or anything else that would be more convenient
in order to state a number on each instructions energy consumption. This is
because this paper investigates how each instruction differs from other
instructions in the same ISA, and thus we look at the power drain at the
processor core when a given instruction resides within it, multiplied by the
number of cycles the instruction consumes. 

During measurements, the core voltage was keept stable at
$1.3V\pm50mV$ during testing. The measurements where done with as full
pipelines as possible, avoiding hazards and instruction loading as much as
possible. This means that instructions that utilize more parts of the processor
will most likely be more energy consuming than those using only few components.
This is also shown with our {\ttfamily baseline}-measurement, as we assume that
the {\ttfamily setend}-instruction merly changes some status flags.



%Some instructions use variable amount of time. This section will contain
%information about how we normalize and compare energy consumption of
%these instructions. It will be difficult to compare single cycle instructions
%to the multi cycle ones, as the single cycle instructions is often the ones
%utilizing more than one ALU at a time. Also, the multi-cycle ones will most
%likely pipeline up very differently than the single cycle ones. We will try to
%draw a conclusion about the results, but it is important to note the differences
%in the execution path of these two categories.

\subsection{Single-Cycle Instructions}
On our target CPU, 70 of the 115 tested instructions\footnote{119 including
conditionals} consumes a single cycle, while the remaining 45 uses 2 or 3.
Because multiply instructions count for nearly half of all tested instructions,
we will discuss them later.
\autoref{fig:singlecycle} displays a comparison of the 50 non-multiply
single-cycle instructions.

\begin{figure}
    \centering
    \includegraphics[width=0.4\textwidth]{figures/graph_01_base_cond-0c6}
    \caption{Energy profile showing conditional execution.}
    \label{fig:cond}
\end{figure}

The results in \autoref{fig:singlecycle} shows that the ordinary single-cycle instructions
does not differ very much. Instructions like {\ttfamily rev} and {\ttfamily sel} are on the
top, which can be explained by looking on how these instructions move nearly all bits in
the operands around, while {\ttfamily cmp} and the different shift-instructios are most likely
moving fewer bits around. A more interesting result is how instructions bearing the {\ttfamily s}-flag
seems to have a lover consumption than their non-{\ttfamily s}-companion. It is hard to reason about
such, since we do not have access to the inner workings of this processor, but according to the performance
counters in \autoref{tab:perf_nonmul}, there is reason to believe that the processor has to do some amount
of idleing, and thus seems to save power. The actual result of being idle some amount of the time is that
more cycles are consumed, and energy is wasted.

The results from the conditional-execution scheme brought by this ISA are also an interesting matter. We
can see from \autoref{fig:cond} how different versions of {\ttfamily add} compares. In the figured test,
{\ttfamily addne} is committed every time, while {\ttfamily addeq} never has its results committed. It is
interesting to see that even though {\ttfamily addeq} is never committed, it uses almost as much power as
the other {\ttfamily add}s. We can assume that with the addition of out-of-order scheduling, conditional
execution might be harder to implement.

\autoref{fig:singlecycle} shows that the {\ttfamily nop}-instruction has a rather low power consumption. This
is a bit missguiding, as the {\ttfamily nop}-instruction is actually a {\ttfamily mov r0,r0}-instruction, and thus
has both a read-after-write and a write-after-write hazard on it self. This makes the {\ttfamily nop}-instruction
serialize it self, and it is hard to fill the pipeline with this instruction. With this in mind, it makes sense
that {\ttfamily nop} works in this way, as it is often used to fill out clock cycles with non-destructive work. It
would not make sense to optimize the {\ttfamily nop} instruction, as it would merly fail to complete it's goal as
a space-and-time filler.

\begin{figure}
    \centering
    \includegraphics[width=0.48\textwidth]{figures/graph_023_base_quad_saturate_extend-0c6}
    \caption{Energy profile of multi-cycle instructions, excluding multiply.}
    \label{fig:multicycle}
\end{figure}


\subsection{Multi-Cycle Instructions}

%See \autoref{fig:multicycle} and \autoref{fig:allmul}
%\begin{itemize}
%    \item The difference between instructions are much larger in the multi-cycle
%        graphs.
%    \item Talk about mul, and why it might differ that much (especially 2 and 3 cycle ones)
%\end{itemize}

45 of the instructions that was compared used 2 or 3 cycles to complete their results. 18 of these instructions are non-multiply.
These non-multiply instructions power measurements are displayed in \autoref{fig:multicycle} and a selection of the performance counter
results are shown in \autoref{tab:perf_nonmul}. We see that the unsigned extend is cheaper than signed extend, which might indicate
that some hardware is left idle when not needing sign extension. The instructions are normalized according to their stated cycle
count in the ARM Cortex-A9 Technical Reference Manual Table B-5\cite{armtech}.

\begin{figure*}
    \centering
    \includegraphics[width=\textwidth]{figures/graph_0123_base_mul-0c6}
    \caption{Energy profile of multiply instructions.}
    \label{fig:allmul}
\end{figure*}

\subsection{Multiply}
We will also discuss the 47 different multiply instructions. Since the ARM
Cortex-A9 only contains a single multiply pipeline, but has two general
ALUs\ref{fig:pipeline}, the multiply instructions are queued up and all are run
though the same pipeline. This means that multiply instructions would have a
lower continous power drain, and thus seem more energy efficient than compared
to the general single-cycle instructions that uses the double amount of ALUs. We
have not compensated for this matter other than multiplying the power drain with
the number of cycles used to finish one multiply instruction, as it is not
published knowledge how the different multiply instructions utilize the
pipelines(s). We have reason to believe that at least some of the
multiply-accumulate instructions utilize both pipelines\cite{ramangcc}, and thus
utlize more hardware while still queueing up through the multiply-enabled main
pipeline.

By looking at \autoref{fig:allmul} we see that the single-cycle multiply
instructions are quite similar, but those using two or three cycles are more
interesting. We do not know why the results are as stated, as most of the
internal architecture are not available for the public. According to the ARM
Cortex-A9 Technical Reference Manual Table B-5, some multiply instructions uses
more time than others before the results are acctually available\cite{armtech}.

\begin{table*}
    \centering
    \begin{tabular}{|l|ccccccc|}
        \hline
        Instr.& Cycles & Main Ex. & Sec. Ex. & Predicted & Mispredicted & No dispatch & Issue Empty \\
        \hline
        \input{table_mul}
        \hline
    \end{tabular}
    \caption{Performance counter regarding multiply instructions}
This table shows data for 252 iterations of 13 instructions each. The mispredicts are most likely due to
the branch predictor cannot correctly predict the first and the last conditional jump in the loop.
    \label{tab:perf_mul}
\end{table*}

\begin{table*}
    \centering
    \begin{tabular}{|l|ccccccc|}
        \hline
        Instr.& Cycles & Main Ex. & Sec. Ex. & Predicted & Mispredicted & No dispatch & Issue Empty \\
        \hline
        \input{table_instr}
        \hline
    \end{tabular}
    \caption{Performance counter regarding selected non-multiply instructions}
    \label{tab:perf_nonmul}
\end{table*}
According to the performance counters in \autoref{tab:perf_mul}, we can see that there is a difference in how each
instruction are beeing handled by the architecture. We have not had enough time to look deeper into each instruction,
but in general will instructions that counts more "No dispatch" or "Issue Empty" have more idle time, thus a lower
overall power drain. The results in \autoref{fig:allmul} show power drain in amperes multiplied by cycle counts stated in the ARM
Cortex-A9 Technical Reference Manual Table B-5\cite{armtech} and is not normalized according to the performance counter values.

\subsection{Evaluation}
\begin{figure}
    \centering
    \includegraphics[width=0.48\textwidth]{figures/heat}
    \caption{Changes in heat and energy consumption for {\ttfamily add} at different runs together with heatsink and ambient temperature}
    \label{fig:heat}
\end{figure}

Each instruction was measured 41 times. For each run, there was small changes in
power consumption, but the relation trends was equal for every run.
As stated in \autoref{sec:temperature}, the power consumption is not easily pushed by temperature. \autoref{fig:heat} shows how the change in power consumption of the instruction
{\ttfamily add} over different runs combined with the ambient temperature the
heatsink temperature. According to these results, we assume that the change in
power consumption was not due to heat. We did not log heat for all test runs,
but assume that the results from \autoref{fig:heat} holds, and that this small
change in heat is not responsible for any disturbance in the power consumption
measurements.


