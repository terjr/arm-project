\section{Results}

%\begin{figure*}
%    \centering
%    \includegraphics[width=1.1\textwidth]{figures/graph_0123_base_lowpower_mul-0c6}
%    \label{fig:allmul}
%\end{figure*}
%
%\begin{figure*}
%    \centering
%    \includegraphics[width=0.7\textwidth]{figures/graph_0123_base_mul-0c7}
%    \label{fig:allmul}
%\end{figure*}
%
%
%
%\begin{figure*}
%    \centering
%    \subfloat[][Multiply]
%    {
%        \includegraphics[width=0.49\textwidth]{figures/graph_123_base_mul-0c5}
%        \label{fig:somemul}
%    }
%    \subfloat[][Single Cycle]
%    {
%        \includegraphics[width=0.49\textwidth]{figures/graph_1_base_arith_data_logic-0c5}
%        \label{fig:singlecycle}
%    }
%    \caption{test}
%\end{figure*}
%\rowcolors{2}{gray!25}{white}

\begin{figure*}[ht]
    \centering
    \includegraphics[width=\textwidth]{figures/graph_01_base_arith_saturate_data_pack_logic-0c6}
    \caption{Energy profile of single-cycle instructions, excluding multiply.}
    \label{fig:singlecycle}
\end{figure*}



\subsection{Introduction}
In this section we present data gathered from our experiments on the ARM
Cortex-A9. A brief description of each instruction can be found in the "ARM and
Thumb-2 Instruction Set Quick Reference Card"\cite{armasmref}.

We distinguish between single-cycle instructions and multi-cycle instructions
because they behave differently in and around the execution pipeline.
Instructions using only one cycle are fairly easy to reason about as there is no
need to normalize energy consumption with respect to the cycle count (i.e.
time). However, it is important to also recognize CPU capabilities such as dual
issuing which are present on the processor: most single-cycle ALU instructions
execute pairwise in parallel -- one in each ALU -- giving a peak performance of
two instructions per clock cycle. Multi-cycle instructions needs to be carefully
considered. Typically, multi-cycle instructions divide work which can be done in
a subset of the available ALUs (e.g. one) over several cycles, and can therefore
introduce bottlenecks in the execution path. This again makes the processor do
less, lowering the average current draw. For all these reasons, we partition the
measured data in two data sets; one for single-cycle instructions and one for
multi-cycle instructions.

In the graphs, all bars colored green means that the tested instruction is a
single-cycle instruction, the light blue is two-cycles, and dark blue is
three-cycle instructions. The red bar is the baseline for current measurement.
This baseline is an alias for the least power-consuming instruction we could
find, which is the \texttt{setend}-instruction. This instruction sets the
endianness regarding memory operations to either big or little endian
\cite{armcompilerref} and setting it to the same endianess repeatedly would
force pipelines to be empty most of the time. The instructions is sorted by
Ampere cycles.

The results presented in the graphs are given in Ampere $\cdot$ cycles, which
means that instructions using more time is normalized by multiplying their
average current drain with the number of cycles used in the pipeline. We are
more interested in how each instruction performs with respect to the other
instructions in the same ISA than looking at specific numbers. Note that this
unit could be converted to Watts or Joules from \autoref{eq:1}.

During measurements, the core voltage was keept stable at $1.3V\pm50mV$, well
within the specifications of the processor. The pipelines were kept as full as
possible, avoiding hazards and instruction loading. This means that instructions
utilizing large parts of the processor will most likely be more energy consuming
than those using only few components. This is confirmed with our
\texttt{baseline}-measurement, as we assume that the \texttt{setend}-instruction
merely changes some status flags.

\subsection{Decomposing the core}
When an instruction is executed within the processor, it will utilize a subset
of all the available components within the core. The ARM cores are in general a
closed product, but by combining the components described in
\autoref{fig:pipeline} with the performance counter data depicted in
\autoref{tab:perf_nonmul} and \autoref{tab:perf_mul}, we can deduce which
instructions that trigger what parts. We can also see how much each component is
used, as a fraction of cycle count and the given components event counter.

\subsection{Performance Counters}
\autoref{tab:perf_nonmul} and \autoref{tab:perf_mul} shows the results from
running each instruction through a loop with 252 iterations. All instructions
have a  correct branch prediction count of 251 (\emph{Pred.}). This is most
likely because the first and the last iteration of the loop is mispredicted
(\emph{Mis pred.}). The cycle count tells us how long time, in terms of clock
cycles, it took for the processor to execute $252 \cdot (13+2)$ instructions. 13
is the number of the tested instruction, the last 2 is \texttt{subs} and
\texttt{jne} as shown in \autoref{list:inst_loop}. \emph{Main Ex.} is the number
of cycles where the main execution pipeline is active, labeled ALU/MUL in
\autoref{fig:pipeline}, \emph{Second Ex.} is for the second execution pipeline,
labeled ALU. \emph{No disp.} is the amount of cycles where there the processor
was not able to dispatch any instructions to any execution pipeline, while
\emph{Issue Empty} is the number of cycles where there was no instructions in
the instruction queue. We can see when the processor is stalling by looking at
the \emph{No disp.} and the \emph{Issue Empty} numbers. When the \emph{No disp.}
number is higher than \emph{Issue Empty}, it means that the processor had to do
stalling, most likely because of hazards. In special cases, such as our baseline
instruction \texttt{setend}, we see that the amount of \emph{No disp.} is
extremely high, which again means that the CPU is mostly stalling. It seems to
be a strong relation between low power usage and high stall numbers.

%Some instructions use variable amount of time. This section will contain
%information about how we normalize and compare energy consumption of
%these instructions. It will be difficult to compare single cycle instructions
%to the multi cycle ones, as the single cycle instructions is often the ones
%utilizing more than one ALU at a time. Also, the multi-cycle ones will most
%likely pipeline up very differently than the single cycle ones. We will try to
%draw a conclusion about the results, but it is important to note the differences
%in the execution path of these two categories.

\subsection{Single-Cycle Instructions}
On our target CPU, 70 of the 115 tested instructions\footnote{119 including
conditionals} use a single cycle, while the remaining 45 uses 2 or 3.
Nearly half of the instructions are multiply instructions, so these will be
discussed separately.

\autoref{fig:singlecycle} displays a comparison of the 50 non-multiply
single-cycle instructions.

\begin{figure}
    \centering
    \includegraphics[width=0.4\textwidth]{figures/graph_01_base_cond-0c6}
    \caption{Energy profile showing conditional execution.}
    \label{fig:cond}
\end{figure}

The results in \autoref{fig:singlecycle} shows that the ordinary single-cycle
instructions do not differ very much. Instructions like \texttt{rev} and
\texttt{sel} are on the top, which can be explained by looking on how these
instructions move nearly all bits in the operands around, while \texttt{cmp} and
the different shift-instructios are most likely moving fewer bits around.

A more interesting result is how instructions bearing the \texttt{s}-flag seems
to have a lower consumption than their non-\texttt{s} companion. These
instructions updates status flags and will likely force in-order execution.
According to the performance counters in \autoref{tab:perf_nonmul} there is
reason to believe that the processor has to stall one cycle between each issue.
This saves power in our synthetic program, but would be inefficient in a real
world scenario.

The results from the conditional-execution scheme brought by this ISA are also
an interesting matter. We can see from \autoref{fig:cond} how different versions
of \texttt{add} compares. In the figured test, \texttt{addne} is committed every
time, while \texttt{addeq} never has its results committed. It is interesting to
see that even though \texttt{addeq} is never committed, it uses almost as much
power as the other \texttt{add}s. We can assume that with the addition of
out-of-order scheduling, conditional execution might be harder to implement.
Also note that this test is very synthetic and the ISA is likely to be
unoptimized for such activity.

\autoref{fig:singlecycle} shows that the \texttt{nop}-instruction has a rather
low power consumption. This is a bit misguiding, as the \texttt{nop}-instruction
assembles to \texttt{mov r0, r0}, having both a read-after-write and a
write-after-write hazard on itself. This makes the \texttt{nop}-instruction
serialize itself, and it is hard to fill the pipeline with this instruction.
Knowing this, it makes sense that \texttt{nop} works in this way, as it is often
used to fill out clock cycles with non-destructive work. It would not make sense
to optimize the \texttt{nop} instruction, as it would merely fail to complete
it's goal as a space-and-time filler.

\begin{figure}
    \centering
    \includegraphics[width=0.48\textwidth]{figures/graph_023_base_quad_saturate_extend-0c6}
    \caption{Energy profile of multi-cycle instructions, excluding multiply.}
    \label{fig:multicycle}
\end{figure}


\subsection{Multi-Cycle Instructions}

%See \autoref{fig:multicycle} and \autoref{fig:allmul}
%\begin{itemize}
%    \item The difference between instructions are much larger in the multi-cycle
%        graphs.
%    \item Talk about mul, and why it might differ that much (especially 2 and 3 cycle ones)
%\end{itemize}

45 of the instructions that was compared used 2 or 3 cycles to complete their
results, and we will discuss them here. 18 of these instructions are
non-multiply. These non-multiply instruction power measurements are displayed in
\autoref{fig:multicycle} and a selection of the performance counter results are
shown in \autoref{tab:perf_nonmul}. We see that the unsigned extend \texttt{ux*}
is slightly cheaper than signed extend \texttt{sx*}, which might indicate that
some hardware is left idle when not needing sign extension. The instructions are
normalized according to their stated cycle count in the table B-5 in
\cite{armtech}.


\begin{table}
    \centering
    \begin{tabular}{|p{0.7cm}|R{0.8cm}R{0.6cm}R{0.85cm}R{0.6cm}R{0.45cm}R{0.75cm}R{0.72cm}|}
       \rowcolor{gray!50}
        \hline
        \centering
        Instr. &
        \centering
        Cycles &
        \centering
        Main Ex. &
        \centering
        Second Ex. &
        \centering
        Pred.&
        \centering
        Mis pred.&
        \centering
        No disp. &
        \begin{centering}
        Issue Empty
        \end{centering}
        \\
        \hline
        \input{table_instr}
        \hline
    \end{tabular}
    \caption{Performance counter data from 252 iterations of all tested
    instructions, excluding multiply.}
    \label{tab:perf_nonmul}
    \hfill
\end{table}

\begin{figure*}
    \centering
    \includegraphics[width=\textwidth]{figures/graph_0123_base_mul-0c6}
    \caption{Energy profile of multiply instructions.}
    \label{fig:allmul}
\end{figure*}

\subsection{Multiply}
We will also discuss the 47 different multiply instructions. Since the ARM
Cortex-A9 only contains a single multiply pipeline, but has two general
ALUs\autoref{fig:pipeline}, the multiply instructions are queued up waiting to
execute through the same pipeline. This implies that multiply instructions would
have a lower continuous power drain because it does less useful work and will
seemingly use less energy compared to instructions utilizing both pipelines at
its full potential. We have not compensated for this matter other than
multiplying the power drain with the number of cycles used to finish one
multiply instruction, as it is not known how the different multiply instructions
utilize the pipeline(s). As we can see from \autoref{tab:perf_mul}, there is
reason to believe that at least some of the multiply-accumulate instructions
utilize both pipelines\cite{ramangcc}, and thus utilize more hardware while
still queuing up through the multiply-enabled main
pipeline.

\begin{table}
    \centering
    \begin{tabular}{|p{0.7cm}|R{0.8cm}R{0.6cm}R{0.85cm}R{0.6cm}R{0.45cm}R{0.75cm}R{0.72cm}|}
       \rowcolor{gray!50}
        \hline
        \centering
        Instr. &
        \centering
        Cycles &
        \centering
        Main Ex. &
        \centering
        Second Ex. &
        \centering
        Pred.&
        \centering
        Mis pred.&
        \centering
        No disp. &
        \begin{centering}
        Issue Empty
        \end{centering}
        \\
        \hline
        \input{table_mul}
        \hline
    \end{tabular}
    \caption{Performance counter data from 252 iterations of all tested multiply
    instructions.}
    \label{tab:perf_mul}
\end{table}

By looking at \autoref{fig:allmul} we see that the single-cycle multiply
instructions are quite similar, but those using two or three cycles are more
interesting. We do not know why the results are as stated, as most of the
internal architecture are not available for the public. According to the ARM
Cortex-A9 Technical Reference Manual Table B-5, some multiply instructions uses
more time than others before the results are actually available\cite{armtech}.

From the performance counters in \autoref{tab:perf_mul}, we see that
instructions are treated differently by the architecture. We have not considered
all the tested instructions in detail, but it is evident to us that there is a
strong the negative correlation between performance counters (\emph{No Disp.}
and \emph{Issue Empty}) and processor power drain. The results in
\autoref{fig:allmul} shows power drain in Amperes multiplied by cycle counts
stated in \cite{armtech} and is not normalized according to the performance
counter values.

\subsection{Evaluation}
\begin{figure}
    \centering
    \includegraphics[width=0.48\textwidth]{figures/heat}
    \caption{Changes in heat and energy consumption for \texttt{add} at
    different runs together with heatsink and ambient temperature}
    \label{fig:heat}
\end{figure}

Each instruction was measured 41 times. We found small variations in power
consumption between testbench runs, but all results shows the same trend.  As
stated in \autoref{sec:temperature}, the power consumption is not easily pushed
by temperature. \autoref{fig:heat} shows how the change in power consumption of
the instruction \texttt{add} over different runs combined with the ambient
temperature and the heatsink temperature. According to these results, we assume
that the change in power consumption was not due to heat. We did not log heat
for all test runs, but assume that the results from \autoref{fig:heat} holds,
and that this small change in heat is not responsible for any disturbance in the
power consumption measurements.
